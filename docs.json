[{"name":"Interpolation","comment":" This module provides a variety of interpolation methods for blending between two values.\nWhile primitives for numbers, colors and lists are provided, the library focuses on composition\nso that you can build interpolators for your own custom datatypes.\n\n@docs Interpolator\n\n\n### Primitive interpolators\n\n@docs float, int, step, rgb, rgbWithGamma, hsl, hslLong\n\n\n### Composition\n\n@docs map, map2, map3, map4, map5, piecewise\n\n\n### Lists\n\n@docs inParallel, list, ListCombiner, combineParallel\n\n\n## Helpers\n\n@docs samples\n\n","unions":[{"name":"ListCombiner","comment":" ","args":[],"cases":[["CombineParallel",[]]]}],"aliases":[{"name":"Interpolator","comment":" An interpolator is merely a function that takes a float parameter `t` roughly in the range [0..1].\n0 would represent the \"before\" value, 1 the after value and values in between are the values in between.\n\nNote: Sometimes the range of the interpolator can go slightly above or below zero - this is useful for some\nanimation techniques. If this is not suitable for your data type, remember to clamp the values as necessary.\n\n","args":["a"],"type":"Basics.Float -> a"}],"values":[{"name":"combineParallel","comment":" Runs all the list interpolations in parallel.\n","type":"Interpolation.ListCombiner"},{"name":"float","comment":" Interpolates between the two provided float values.\n\n    myInterpolator : Interpolator Float\n    myInterpolator = Interpolation.float 5 17\n\n    myInterpolator 0.2 -- 7.4\n    myInterpolator 0.5 -- 11\n\n","type":"Basics.Float -> Basics.Float -> Interpolation.Interpolator Basics.Float"},{"name":"hsl","comment":" Interpolates between two Color values using the HSL color space. It will always take the shortest path between the target hues.\n","type":"Color.Color -> Color.Color -> Interpolation.Interpolator Color.Color"},{"name":"hslLong","comment":" Like `Interpolation.hsl`, but does not use the shortest path between hues.\n","type":"Color.Color -> Color.Color -> Interpolation.Interpolator Color.Color"},{"name":"inParallel","comment":" This will run all of the interpolators provided in parallel.\n\nCan be handy for constructing complex interpolations in conjuction with `List.map2`:\n\n    before : List Float\n    before =\n         [ 3, 4, 7, 8 ]\n\n    after : List Float\n    after =\n         [ 6, 4, 1, 9 ]\n\n    myInterpolator0 : Interpolator (List Float)\n    myInterpolator0 =\n         List.map2 Interpolation.float before after\n             |> Interpolation.inParallel\n\n    myInterpolator0 0 --> [ 3, 4, 7, 8 ]\n    myInterpolator0 0.5 --> [ 4.5, 4, 4, 8.5]\n    myInterpolator0 1 --> [ 6, 4, 1, 9 ]\n\n","type":"List.List (Interpolation.Interpolator a) -> Interpolation.Interpolator (List.List a)"},{"name":"int","comment":" Interpolates between ints.\n","type":"Basics.Int -> Basics.Int -> Interpolation.Interpolator Basics.Int"},{"name":"list","comment":" This is an interpolator for lists. It is quite complex and should be used if these conditions hold:\n\n1.  You need to interpolate additions, removals and changes.\n2.  Each item in the list has some notion of identity, for example an `.id` member, which is `comparable`.\n3.  You have a way to deal with positions in the list being somewhat muddy during the transition (e.g. if an item is being created at the same position a different item is being removed, while adjacent items are switching position, then the exact order of items will be arbitrary during the interpolation).\n\nThe first argument is a configuration record. It has the following keys:\n\n  - `id : a -> comparable` is a function that retrieves some sort of identifier for each item in the list. It is used to figure out if an item is added, removed, or modified.\n  - `add : a -> Interpolator a` will be invoked for each item being added to the list.\n  - `remove : a -> Interpolator a` will be invoked for each item disappearing from the list. Note that the item won't actually be removed from the list until `t = 1`, so you will most likely want to make the item disappear visually.\n  - `change : a -> a -> Interpolator a` is called for an item where the `id` matches for both lists, but which are not equal.\n  - `combine : ListCombiner` configures a strategy that orchestrates all the interpolations created. At the moment only 'combineParallel' is supported, but staggered transitions will be supported in the future.\n\n","type":"{ add : a -> Interpolation.Interpolator a, remove : a -> Interpolation.Interpolator a, change : a -> a -> Interpolation.Interpolator a, id : a -> comparable, combine : Interpolation.ListCombiner } -> List.List a -> List.List a -> Interpolation.Interpolator (List.List a)"},{"name":"map","comment":" Transform values from another interpolator.\n\nNote: This function is provided as a convenience, since thinking in `mapN` is pretty natural for Elm developers (and\nworks well in pipelines). However, keep in mind that this function is literally an alias for `<<`.\n\n","type":"(a -> b) -> Interpolation.Interpolator a -> Interpolation.Interpolator b"},{"name":"map2","comment":" Combine two interpolators, combining them with the given function.\n\n    type alias Coords =\n        ( Float, Float )\n\n    interpolateCoords : Coords -> Coords -> Interpolator Coords\n    interpolateCoords ( x1, y1 ) ( x2, y2 ) =\n        Interpolation.map2\n            Tuple.pair\n            (Interpolation.float x1 x2)\n            (Interpolation.float y1 y2)\n\n","type":"(a -> b -> c) -> Interpolation.Interpolator a -> Interpolation.Interpolator b -> Interpolation.Interpolator c"},{"name":"map3","comment":" ","type":"(a -> b -> c -> d) -> Interpolation.Interpolator a -> Interpolation.Interpolator b -> Interpolation.Interpolator c -> Interpolation.Interpolator d"},{"name":"map4","comment":" ","type":"(a -> b -> c -> d -> e) -> Interpolation.Interpolator a -> Interpolation.Interpolator b -> Interpolation.Interpolator c -> Interpolation.Interpolator d -> Interpolation.Interpolator e"},{"name":"map5","comment":" ","type":"(a -> b -> c -> d -> e -> f) -> Interpolation.Interpolator a -> Interpolation.Interpolator b -> Interpolation.Interpolator c -> Interpolation.Interpolator d -> Interpolation.Interpolator e -> Interpolation.Interpolator f"},{"name":"piecewise","comment":" Returns a piecewise interpolator, composing interpolators for each adjacent pair of values.\n\nFor example:\n\n    myInterpolator : Interpolator Int\n    myInterpolator =\n         Interpolation.piecewise Interpolation.int 6 [ 10, -2 ]\n\n    myInterpolator 0 --> 6\n    myInterpolator 0.25 --> 8\n    myInterpolator 0.5 --> 10\n    myInterpolator 0.75 --> 4\n    myInterpolator 1 --> -2\n\n","type":"(a -> a -> Interpolation.Interpolator a) -> a -> List.List a -> Interpolation.Interpolator a"},{"name":"rgb","comment":" Interpolates between two Color values using the sRGB color space.\n","type":"Color.Color -> Color.Color -> Interpolation.Interpolator Color.Color"},{"name":"rgbWithGamma","comment":" Interpolates between two Color values using the sRGB color space using [gamma correction](https://web.archive.org/web/20160112115812/http://www.4p8.com/eric.brasseur/gamma.html).\n","type":"Basics.Float -> Color.Color -> Color.Color -> Interpolation.Interpolator Color.Color"},{"name":"samples","comment":" Returns a list of uniformly spaced samples from the specified interpolator. The first sample is always at t = 0, and the last sample is always at t = 1. This can be useful in generating a fixed number of samples from a given interpolator.\n\nCan be quite handy when debugging interpolators or as a way to create a quantize scale.\n\n","type":"Basics.Int -> Interpolation.Interpolator a -> List.List a"},{"name":"step","comment":" Interpolate between arbitrary values by just showing them in sequence.\n\nThe list is provided is passed as head and tail seperately, to avoid needing to handle the empty list case.\n\n     type StageOfGrief\n         = Denial\n         | Anger\n         | Bargaining\n         | Depression\n         | Acceptance\n\n     griefInterpolator : Interpolator StageOfGrief\n     griefInterpolator =\n         Interpolation.step Denial\n             [ Anger\n             , Bargaining\n             , Depression\n             , Acceptance\n             ]\n\n     griefInterpolator 0 --> Denial\n     griefInterpolator 0.5 --> Bargaining\n     griefInterpolator 1.1 --> Acceptance\n\n","type":"a -> List.List a -> Interpolation.Interpolator a"}],"binops":[]},{"name":"Transition","comment":" Transition is a module for writing animations. It does not attempt to be an animation library for every use case,\nit is specifically designed for the needs of data visualization apps. The main idea is that one animates data in some\nintermediate form and then leaves the `view` function to display the data as normal.\n\n\n### Setting up animation in an app\n\nWhile there are many ways to use this module, a typical setup will look like this:\n\n    import Browser.Events\n    import Interpolation exposing (Interpolator)\n    import Transition exposing (Transition)\n\n    type alias Model =\n        { transition : Transition MyThing\n        }\n\n    type Msg\n        = Tick Int\n        | StartAnimation MyThing\n\nFirst setup a default transition that doesn't actually do anything:\n\n    init : () -> ( Model, Cmd Msg )\n    init () =\n        ( { transition = Transition.constant initialThing }\n        , Cmd.none\n        )\n\nNext setup a subscription:\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        if Transition.isComplete model.transition then\n            Sub.none\n\n        else\n            Browser.Events.onAnimationFrameDelta (round >> Tick)\n\nDefine an interpolator for your value:\n\n    interpolateThing : MyThing -> MyThing -> Interpolator MyThing\n    interpolateThing from to =\n         -- ...\n\nThen handle stuff in your update function:\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            Tick t ->\n                ( { model\n                    | transition = Transition.step t model.transition\n                  }\n                , Cmd.none\n                )\n\n            StartAnimation newThing ->\n                let\n                    oldThing =\n                        Transition.value model.transition\n                in\n                ( { model\n                    | transition =\n                        Transition.for 600 (interpolateThing oldThing newThing)\n                  }\n                , Cmd.none\n                )\n\nThen make your view like normal:\n\n    view : Model -> Html Msg\n    view model =\n        viewMyThing (Transition.value model.transition)\n\n    viewMyThing : MyThing -> Html Msg\n    viewMyThing thing =\n        --- ...\n\n\n## Transitions\n\n@docs Transition, for, easeFor, constant, step, value, isComplete\n\n\n## Easing\n\n@docs Easing, easeLinear, easeCubic\n\n","unions":[{"name":"Easing","comment":" Easing is a method of distorting time to control apparent motion in animation. It is most commonly used for [slow-in, slow-out](https://en.wikipedia.org/wiki/Twelve_basic_principles_of_animation#Slow_In_and_Slow_Out). By easing time, animated transitions are smoother and exhibit more plausible motion.\n","args":[],"cases":[]},{"name":"Transition","comment":" A transition is a smooth interpolation between a beginning state and an end state, with a duration and easing.\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"constant","comment":" A transition that is already complete that will always return the value passed in.\n","type":"a -> Transition.Transition a"},{"name":"easeCubic","comment":" Symetric cubic easing. This is quite a good default for a lot of animation.\n","type":"Transition.Easing"},{"name":"easeFor","comment":" This is like `Transition.for`, but allows one to specify a custom Easing function. `Transition.for` defaults to `Transition.easeCubic`.\n","type":"Basics.Int -> Transition.Easing -> Interpolation.Interpolator a -> Transition.Transition a"},{"name":"easeLinear","comment":" Linear easing is esentially the identity function of easing.\n","type":"Transition.Easing"},{"name":"for","comment":" Create a transition that will run _for_ a certain number of miliseconds. You need to provide an interpolation between the start and end states.\n\nFor example to fade something in for 400ms:\n\n    fadeIn : Item -> Transition Item\n    fadeIn item =\n        Interpolation.map (\\opacity -> { item | opacity = opacity)\n            (Interpolation.float 0 1)\n            |> Transition.for 400\n\n","type":"Basics.Int -> Interpolation.Interpolator a -> Transition.Transition a"},{"name":"isComplete","comment":" Allows you to check if a transition has finished running. This can be used to clean up subscriptions.\n","type":"Transition.Transition a -> Basics.Bool"},{"name":"step","comment":" Updates the internal state forward by the passed number of miliseconds. You would typically do this in your `update` function.\n","type":"Basics.Int -> Transition.Transition a -> Transition.Transition a"},{"name":"value","comment":" Returns the \"current\" value. You would typically call this in the view and render whatever this returns.\n\n    import Interpolation\n\n    transition : Transition Int\n    transition =\n        Transition.easeFor 500 Transition.easeLinear (Interpolation.int 0 10)\n\n    transition |> Transition.value --> 0\n    transition |> Transition.step 250 |> Transition.value --> 5\n    transition |> Transition.step 600 |> Transition.value --> 10\n\n","type":"Transition.Transition a -> a"}],"binops":[]}]